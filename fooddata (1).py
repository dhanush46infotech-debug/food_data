# -*- coding: utf-8 -*-
"""FOODDATA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bi8vQNPEHSRwmQAD3VmM3kPUG_dXjChB

"""

# Cell 1 - Install required libraries

"""**IMPORT LIBRARIES**"""

import pandas as pd # Data Manipulation
import numpy as np  #Numerical Computations
import matplotlib.pyplot as plt #Data Visualization
import seaborn as sns #Data Visualization
import scipy.stats as stats #Statistical Analysis
import re #Regular Expressions
#to ignore warnings
import warnings
warnings.filterwarnings('ignore')

# Handle display function for both Jupyter and regular Python
try:
    from IPython.display import display  # type: ignore
except ImportError:
    # If IPython is not available, use print instead
    def display(obj):
        print(obj)

"""**DATA UNDERSTANDING**

**LOAD DATASET**
"""

# Update this path to your actual CSV file location
# For Downloads folder: food_df = pd.read_csv('C:/Users/HP/Downloads/indian_food.csv', header=0)
# For current directory: food_df = pd.read_csv('indian_food.csv', header=0)
food_df = pd.read_csv('indian_food.csv', header=0)
food_df.columns = food_df.columns.str.replace(' ', '_').str.lower()

"""**Dataset Summary (Size, Structure, Initial Findings)**"""

#SIZE
print( "Dataset Size (Rows, Columns):")
print(food_df.shape)

#Structure
print("Dataset Structure (Column Names & Dtypes):")
print(food_df.dtypes)

"""**INITIAL FINDINGS**"""

#Display first 5 rows [0->4]
print("Initial Data Preview (head):")
display(food_df.head())

display(food_df.iloc[0:5])

print("Columns:")
print(food_df.columns)

#to Get information of data
food_df.info()

"""**data.info() shows that the variables Food Name, Ingredients, Veg/Non veg, cook_time, flavor_profile, course, and state contain missing values.
<br>The dataset has 6 categorical variables (Food Name, Ingredients, Veg/Non veg, flavor_profile, course, state), all stored as object datatype.
<br>It has 1 numerical variable, cook_time, which is of datatype float64**

Missing Values Summary
"""

# Missing values
print(food_df.isna().sum())

# Basic statistics (numeric columns only)
print(food_df.describe())

# Unique values in each column
print(food_df.nunique())

# Missing Values Calculation
print("\nMissing Values Count:")
print(food_df.isnull().sum())

# calculate the percentage of missing values in each column
print("\nMissing Values Percentage:")
print((food_df.isnull().sum()/(len(food_df)))*100)

"""DUPLICATE FINDINGS"""

# Duplicate Records

# Count duplicates
duplicate_count = food_df.duplicated().sum()
print("Total Duplicate Rows:", duplicate_count)

# Display sample duplicates
if duplicate_count > 0:
    display(food_df[food_df.duplicated()].head())

# Remove duplicates
food_df = food_df.drop_duplicates()
print("\nDuplicates removed. New shape:", food_df.shape)

"""Detect Outliers (IQR Method)"""

num_cols = food_df.select_dtypes(include=['int64', 'float64']).columns

for col in num_cols:
    Q1 = food_df[col].quantile(0.25)
    Q3 = food_df[col].quantile(0.75)
    IQR = Q3 - Q1

    lower = Q1 - 1.5 * IQR
    upper = Q3 + 1.5 * IQR

    outliers = food_df[(food_df[col] < lower) | (food_df[col] > upper)]
    print(f"{col}: {len(outliers)} outliers")

"""Outliers sample
normal cook time = 10 to 50 minutes
But your dataset has values like:
0
1
0
200
300
45
...


this values are known as outliers
"""

# A2 - Remove outliers using IQR method (standard statistical approach)
col = 'cook_time'
series = food_df[col].dropna()

Q1 = series.quantile(0.25)
Q3 = series.quantile(0.75)
IQR = Q3 - Q1
lower = Q1 - 1.5 * IQR
upper = Q3 + 1.5 * IQR

clean_by_iqr = food_df[(food_df[col] >= lower) & (food_df[col] <= upper)].copy()

print(f"IQR lower = {lower:.2f}, upper = {upper:.2f}")
print("Original rows:", len(food_df))
print("After removing IQR outliers:", len(clean_by_iqr))

# Show removed outliers
removed_iqr = food_df[(food_df[col] < lower) | (food_df[col] > upper)]
print("\nIQR Outlier rows (sample):")
display(removed_iqr.head())

# C1 - Boxplot visualization using matplotlib (single column)
plt.figure(figsize=(6,4))
plt.boxplot(food_df['cook_time'].dropna(), vert=False)
plt.title('Boxplot of cook_time (shows outliers as points)')
plt.xlabel('cook_time (minutes)')
plt.show()

#Boxplot to see outliers in seaborn
# C2 - Boxplot by category (if you want to see distribution by Veg/Non veg)
if 'veg/non_veg' in food_df.columns:
    plt.figure(figsize=(8,4))
    sns.boxplot(x='cook_time', y='veg/non_veg', data=food_df)
    plt.title('cook_time for food')
    plt.xlabel('cook_time (minutes)')
    plt.show()
else:
    print("Column 'veg/non_veg' not found. Run single-column boxplot (Cell C1) instead.")

"""FINDING INCONSISTENT RECORDS"""

# 1) Negative values (not logical for food dataset)
num_cols = food_df.select_dtypes(include=['int64','float64']).columns
neg_values = food_df[num_cols][food_df[num_cols] < 0].dropna(how='all')

print("\nNegative Values Found:")
display(neg_values.head())

# 2) Check inconsistent categories example (cuisine)
if "cuisine" in food_df.columns:
    display(food_df["cuisine"].value_counts())
    display(food_df["cuisine"].unique())
else:
    print("Column 'cuisine' not found.")

if "Ingredients" in food_df.columns:
    display(food_df["Ingredients"].value_counts())
    display(food_df["Ingredients"].unique())
    display(food_df["Ingredients"].nunique())
else:
    print("Column 'cuisine' not found.")

"""**✔ Derived metrics**"""

# Derived Metric 1: Length of dish name
food_df['name_length'] = food_df['food_name'].astype(str).apply(len)
food_df['name_word_count'] = food_df['food_name'].astype(str).apply(lambda x: len(x.split()))

print("Created: name_length, name_word_count")
display(food_df[['food_name', 'name_length', 'name_word_count']].head())

"""FEATURE ENGINEERING

"""

# Feature Engineering Example for Food Dataset

# Introducing a new column: "Prep_Time_Category"
# to classify how long the dish takes to prepare

if 'cook_time' in food_df.columns:

    def categorize_prep_time(t):
        if t <= 20:
            return "Quick"
        elif t <= 45:
            return "Medium"
        else:
            return "Long"

    food_df['Prep_Time_Category'] = food_df['cook_time'].apply(categorize_prep_time)

    print("Created feature: Prep_Time_Category")
    display(food_df[['cook_time', 'Prep_Time_Category']].head())

else:
    print("Column 'cook_time' not found in your dataset.")

# 1. Create the Category Column

def categorize_prep_time(x):
    if x <= 20:
        return "Short"
    elif x <= 50:
        return "Medium"
    else:
        return "Long"

# Apply only if column exists
if 'cook_time' in food_df.columns:
    food_df['Prep_Time_Category'] = food_df['cook_time'].apply(categorize_prep_time)
    print("New Feature Prep Time has Created Successfully!")
else:
    print("ERROR: 'cook_time' column missing!")

# 2. Check Columns

print("\nAvailable Columns:")
print(food_df.columns.tolist())

# 3. Verify if column created

if 'Prep_Time_Category' in food_df.columns:
    print("\nUnique Categories:", food_df['Prep_Time_Category'].unique())
    print("Number of Categories:", food_df['Prep_Time_Category'].nunique())
else:
    print("\nColumn 'Prep_Time_Category' NOT FOUND")

"""# **DATA VISUALIZATON**

FILTERING
"""

# Dishes that take less than 20 minutes
if 'cook_time' in food_df.columns:
    quick_dishes = food_df[food_df['cook_time'] < 20]
    print("\nQuick Dishes (< 20 minutes):")
    display(quick_dishes.head())
else:
    print("\nWarning: 'cook_time' column not found")

if 'veg/non_veg' in food_df.columns:
    veg_dishes = food_df[food_df['veg/non_veg'] == 'vegetarian']
    print("\nVegetarian Dishes:")
    display(veg_dishes.head())
else:
    print("\nWarning: 'veg/non_veg' column not found")

"""# **STATISTICAL ANALYSIS**   
Apply statistical hypothesis testing to validate findings.
"""

# ===== Descriptive Statistics =====

print("=== NUMERIC SUMMARY ===")
num_cols = food_df.select_dtypes(include=['int64','float64']).columns
display(food_df[num_cols].describe())

print("\n=== CATEGORICAL SUMMARY ===")
cat_cols = food_df.select_dtypes(include=['object']).columns
for col in cat_cols:
    print(f"\nColumn: {col}")
    print(food_df[col].value_counts().head())

#Mean,Median & Mode

for col in num_cols:
    print(f"\nColumn: {col}")
    print("Mean   :", food_df[col].mean())
    print("Median :", food_df[col].median())
    print("Mode   :", food_df[col].mode()[0])

#Correlation Between Numeric Variables
corr_matrix = food_df[num_cols].corr()
display(corr_matrix)

"""# HYPOTHESIS TEST

# **F-test**
"""

from scipy.stats import f_oneway

# Check if required columns exist
if 'state' in food_df.columns and 'cook_time' in food_df.columns:
    # Get unique states and create groups for cook_time
    state_groups = []
    for state in food_df['state'].dropna().unique():
        # Only include non-null states and drop NaN cook_time values
        cook_times_for_state = food_df[food_df['state'] == state]['cook_time'].dropna()
        if not cook_times_for_state.empty and len(cook_times_for_state) > 1:
            state_groups.append(cook_times_for_state)

    # Perform F-Test if there are enough groups
    if len(state_groups) > 1:
        F_stat, p_val = f_oneway(*state_groups)

        print("=== F-TEST: Cook Time across States ===")
        print("F-statistic:", F_stat)
        print("P-value:", p_val)
    else:
        print("Not enough groups with data to perform F-test.")
else:
    print("Warning: Required columns 'state' or 'cook_time' not found for F-test")

"""# **T-TEST**"""

#HYPOTHESIS TEST 1
#T-TEST: Compare Cook Time between Two Regions
from scipy.stats import ttest_ind

# Using 'state' column
# Choosing two states with sufficient data for comparison
if 'state' in food_df.columns and 'cook_time' in food_df.columns:
    group1 = food_df[food_df['state']=='Punjab']['cook_time'].dropna()
    group2 = food_df[food_df['state']=='Maharashtra']['cook_time'].dropna()

    if len(group1) > 1 and len(group2) > 1:
        t_stat, p_val = ttest_ind(group1, group2, equal_var=False)

        print("=== T-TEST: Cook Time (Punjab vs Maharashtra) ===")
        print("T-statistic:", t_stat)
        print("P-value    :", p_val)
    else:
        print("Warning: Insufficient data for Punjab or Maharashtra to perform T-test")
else:
    print("Warning: Required columns 'state' or 'cook_time' not found for T-test")

"""## **CHI-SQUARE TEST**"""

from scipy.stats import chi2_contingency

if 'state' in food_df.columns and 'flavor_profile' in food_df.columns:
    table = pd.crosstab(food_df['state'].dropna(), food_df['flavor_profile'].dropna())

    if table.size > 0:
        chi2, p, dof, expected = chi2_contingency(table)

        print("=== CHI-SQUARE TEST: State ↔ Flavor Profile ===")
        print("Chi-square:", chi2)
        print("P-value   :", p)
        print("Degrees of freedom:", dof)
    else:
        print("Warning: Insufficient data for Chi-square test")
else:
    print("Warning: Required columns 'state' or 'flavor_profile' not found for Chi-square test")

"""# **DATA VISUALIZATION**

UNI VARIATE
"""

plt.hist(food_df['cook_time'].dropna(), bins=20)
plt.title("Histogram of Cook Time")
plt.xlabel("Cook Time")
plt.ylabel("Frequency")
plt.show()

plt.boxplot(food_df['cook_time'].dropna())
plt.title("Boxplot of Cook Time")
plt.show()

"""BI-VARIATE"""

states = food_df['state'].value_counts().index.tolist()
data = [food_df[food_df['state'] == s]['cook_time'].dropna() for s in states]
plt.boxplot(data, labels=states, vert=False)
plt.title("Cook Time by State")
plt.show()

if 'state' in food_df.columns and 'cook_time' in food_df.columns:
    state_list = food_df['state'].value_counts().index.tolist()

    data = [food_df[food_df['state']==s]['cook_time'].dropna() for s in state_list]

    plt.boxplot(data, labels=state_list, vert=False)
    plt.title("Cook Time by State")
    plt.show()
else:
    print("Column missing for boxplot analysis")

"""**MULTIVARIATE ANALYSIS**"""

num_cols = food_df.select_dtypes(include=[np.number]).columns

corr = food_df[num_cols].corr()

plt.imshow(corr, cmap='viridis')
plt.colorbar()
plt.xticks(range(len(num_cols)), num_cols, rotation=45)
plt.yticks(range(len(num_cols)), num_cols)
plt.title("Correlation Heatmap")
plt.show()

#Multivariate (Scatter Matrix)
from pandas.plotting import scatter_matrix

# Select numerical columns that actually exist in the dataset
valid_num_cols = ['cook_time', 'name_length', 'name_word_count']

# Check if all columns exist before creating scatter matrix
if all(col in food_df.columns for col in valid_num_cols):
    scatter_matrix(food_df[valid_num_cols], figsize=(10,8))
    plt.suptitle("Scatter Matrix")
    plt.show()
else:
    print("Warning: Some columns missing for scatter matrix. Available columns:", food_df.columns.tolist())